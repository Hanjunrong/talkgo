## Linux 性能优化实战

[Linux 性能优化实战 by 倪朋飞](https://time.geekbang.org/column/intro/140)

#### [01-如何学习Linux性能优化？](https://time.geekbang.org/column/article/69346)

> 笔记

* 概念
    * 性能优化的一般步骤（和性能测试的一般步骤很像）
        * 选择性能指标
        * 设置性能目标
        * 选择性能测试(调试)工具
        * 性能测试和分析
        * 性能优化
        * 性能监控和预警
    * 性能指标
        * 应用指标
            * QPS/RT 和其他
                * C 并发数 N 请求总数 T 总耗时
                * QPS = N / T
                * RT = T / N * C
                * QPS = C / RT 
        * 系统指标
            * cpu/内存/磁盘io/网络io

> 金句

**学习的重点是，建立整体系统性能的全局观**

我对这句话体会颇深，对于线上问题，如果一开始就钻到细节，而不是全局分析，容易走入死胡同，浪费时间；
正确的方法是，先分析网络拓扑，搞清楚服务链路，整体查看调用情况，并根据监控数据对比分析（一定要对比），
找到异常点，再针对它深入分析。这其实就是一种全局观，它要求我们具备一种对问题的综合认知能力，对涉及
性能或功能的方方面面有一个全局多维度的掌握。对于性能优化，我想也是这样，如果你只了解一个工具，一种指标，
那么你就只能或只会想到一个方法，实际上性能问题大多数是综合问题，仅靠"一把铁锤"是无法解决问题的，把这句
话当做学习的目标吧：建立整体系统性能的全局观。

> 问题

1. 你们是怎么做性能测试或压力测试的？一般流程有哪些？
2. 一般的应用性能指标有哪些？它是怎么统计的?

#### [02-基础篇：到底应该怎么理解“平均负载”?](https://time.geekbang.org/column/article/69618)

> 笔记

* 概念
    * 平均负载 = 平均活跃进程数（R和D状态的进程）
    * 进程状态: [状态机](./img/process_state_machine.png)
    * cpu逻辑核心数(processor) = cpu物理个数(physic id) * 单个cpu核心数（core id) * 单核线程数 

* 工具
    * 压测工具
        * stress/stress-ng -> 模拟cpu/io/多线程压力
    * 性能分析工具
        * mpstat -> 分析cpu每个逻辑核心的时间占用
        * pidstat -> 分析进程级别的cpu时间占用

> 金句

* 你真的知道每列的含义吗

言外之意，我们通常只知道某列或少数几列的含义，似懂非懂，对工具掌握不全面，容易陷入"铁锤人"思维。

> 发现问题

1. 进程包含哪些状态，状态之间如何转换？
2. 什么是平均负载？一般怎么分析该指标？
3. 如何排查导致负载升高的进程？

> 分享精华

#### [03 | 基础篇：经常说的 CPU 上下文切换是什么意思？（上）](https://time.geekbang.org/column/article/69859)

> 笔记

* 上下文 -> 任务执行所依赖的资源
    * 内核态上下文
        * 指令 -> 寄存器/程序计数器(PC是寄存器的一种，存储指令及其执行位置）
        * 内核堆栈等
    * 用户态上下文
        * 虚拟内存 -> 页表和TLB
        * 用户栈
        * 全局变量等

* 上下文切换 -> 保存（保存到内核管理的内存中）旧任务上下文，加载新任务上下文
    * 进程间切换 -> 调度两个不同进程的线程
    * 线程间切换 -> 调度进程内的不同线程
    * 中断切换 -> 响应硬件异步信号（例如点击鼠标，收到一个网络包等）
    * 内核模式切换 -> 系统调用， 进程内在用户态(ring3)和内核态(ring0)之间切换
    * 协程切换 -> 在用户态完成切换（其他模式再内核完成切换）

**ps: 开销排名 进程间切换 > 线程间切换(同进程）> 中断切换 > 内核模式切换/协程切换, 切换时间算为cpu sys 时间**
**ps: 进程内切换无需切换虚拟内存等进程级别的资源**

* 进程切换的原因
    * 非自愿
        * cpu时间片耗尽
    * 自愿
        * 资源不足，例如内存不足
        * 主动sleep
        * 有更高优先级的进程出现
        * 中断
    
> 金句

**线程是调度的基本单位，进程是资源拥有的基本单位**

理解这句话才能更好的理解上下文切换，实际上进程间的切换本质上是线程在两个不同
的进程之间发生调度。

> 问题

1. 什么是cpu的上下文切换？为什么说上下文切换会产生性能开销?
2. 进程在什么情况下会被挂起？说说进程调度的策略有哪些？
3. 为什么说golang的协程比java的线程模型开销更小，能否从上下文切换的角度分析？

#### [04 | 基础篇：经常说的 CPU 上下文切换是什么意思？（下）](https://time.geekbang.org/column/article/70077)

> 笔记

* 概念
    * cpu上下文切换过多的现象
        * 平均负载升高
        * cpu sys 升高
        * cpu 切换次数变多
            * 通过vmstat或pidstat可查看

    * cpu上下文切换次数受什么影响
        * cpu本身的性能
        * 系统负载
        
        
* 工具
    * vmstat -> 查看系统整体资源使用(cpu/内存/上下文切换）
        * vmstat 5 -> 5s钟输出一次
            * in -> 中断次数
            * cs -> 上下文切换总次数
            * r -> 就绪进程数
            * b -> 不可中断睡眠进程数（相当于D状态）
        * vmstat 输出第一行是系统启动以来的平均值, 接下来才是实时值

    * sysbench -> 压力测试工具
        * 模拟多线程任务
          * sysbench --threads=10 --max-time=300 threads run
        * stress -c 是模拟多进程，它会引起进程上下文切换
    
    * pidstat -> 分析进程资源使用
        * pidstat -wut 5
            * -w -> 显示上下文切换
                * cswch/s -> 自愿切换(资源不足）
                * nvcswch/s -> 非资源切换（cpu时间片用完）
            * -u -> 显示cpu
            * -t -> 显示线程级别的上下文切换
                * 否则只显示进程级别切换，无法体现线程上下文切换的情况, 与vmstat统计的次数对不上

    * /proc/interrupt -> 查看系统中断
        * cat /proc/interrupts  | sort -nr -k 2 -> 按切换次数排序
        * RES -> 处理器间中断 (调度器唤醒cpu时触发）
            * 进程竞争激烈时，除了导致上下文切换增加，同时也会引起RES的明显增加(比平稳情况下增加的更多）
            * 现象是vmstat查出来 in 和 cs变多
            * 单核CPU可能没有RES

> 最佳实践

* 用zabbix等工具监控cpu的上下文切换和中断时间，只有明显变化(指数级）才去关注分析它

> 问题

* 怎么查看cpu上下文切换次数？多少次是不正常的呢？
* cpu上下文切换次数过多会导致cpu使用率变高吗？


